```planetext
**Вопрос 1.** В Python список — одна из самых популярных структур данных,
способная хранить последовательность элементов. Что произойдет, если
использовать метод append() для добавления элемента, а затем метод
extend() для добавления другой последовательности в тот же список?

A. Метод append() добавит каждый символ нового элемента по отдельности,
а extend() создаст новый список внутри существующего.

B. Метод append() добавит новый элемент как единый объект в конец
списка, в то время как extend() переберет элементы последовательности
и добавит каждый из них в исходный список по отдельности.

C. Оба метода добавят содержимое одинаково, создавая вложенный список
внутри оригинального списка.

D. Метод append() заменяет существующий список, а extend() очищает его
перед добавлением новой последовательности.

Правильный ответ: B

Объяснение: Метод append() добавляет свой аргумент как один элемент
в конец списка (даже если это другой список). Метод extend() итерирует
по элементам аргумента и добавляет их в список по отдельности.

**Вопрос 2.** В программировании на Python цикл 'for' очень гибок для
итерации по различным объектам. Рассмотрите сценарий, в котором у вас есть
словарь со строковыми ключами и целыми значениями. Какой из следующих
вариантов правильно итерирует одновременно по ключам и значениям этого
словаря?

A. for key, value in dictionary.items(): print(key, value)
B. for key in dictionary: print(key, dictionary[key])
C. for value in dictionary.values(): print(value)
D. for key in dictionary.keys(): print(key)

Правильный ответ: A

Объяснение: Метод items() возвращает объект представления, содержащий
пары кортежей «ключ-значение». Это позволяет одновременно итерировать по
ключам и значениям в цикле 'for', что невозможно сделать, используя
только методы keys() или values().

**Вопрос 3.** В Python области видимости переменных имеют решающее значение
для понимания того, как осуществляется доступ к переменным или их
изменение внутри вложенных блоков кода. Если переменная с тем же именем
определена как внутри функции, так и вне ее, что произойдет, когда
функция попытается изменить эту переменную без использования каких-либо
дополнительных ключевых слов?

A. Функция напрямую изменит глобальную переменную без каких-либо ошибок.

B. Python выдаст ошибку SyntaxError из-за конфликта областей видимости.

C. Функция создаст новую локальную переменную с тем же именем, что и у
глобальной переменной, оставив глобальную переменную без изменений.

D. Глобальная переменная будет затененной, и ее значение изменится только
после завершения работы функции.

Правильный ответ: C

Объяснение: В Python переменные, объявленные внутри функции, по умолчанию
считаются локальными для этой функции. Если переменная с таким же именем
существует глобально, любые изменения внутри функции не затронут
глобальную переменную, если только не было явно использовано ключевое
слово 'global'.
```