```planetext
**Вопрос 1.** В Python список — одна из самых популярных структур данных,
способная хранить последовательность элементов. Что произойдет, если
использовать метод append() для добавления элемента, а затем метод
extend() для добавления другой последовательности в тот же список?

A. Метод append() добавит каждый символ нового элемента по отдельности,
а extend() создаст новый список внутри существующего.

B. Метод append() добавит новый элемент как единый объект в конец
списка, в то время как extend() переберет элементы последовательности
и добавит каждый из них в исходный список по отдельности.

C. Оба метода добавят содержимое одинаково, создавая вложенный список
внутри оригинального списка.

D. Метод append() заменяет существующий список, а extend() очищает его
перед добавлением новой последовательности.

Правильный ответ: B

Объяснение: Метод append() добавляет свой аргумент как один элемент
в конец списка (даже если это другой список). Метод extend() итерирует
по элементам аргумента и добавляет их в список по отдельности.

**Вопрос 2.** В программировании на Python цикл 'for' очень гибок для
итерации по различным объектам. Рассмотрите сценарий, в котором у вас есть
словарь со строковыми ключами и целыми значениями. Какой из следующих
вариантов правильно итерирует одновременно по ключам и значениям этого
словаря?

A. for key, value in dictionary.items(): print(key, value)
B. for key in dictionary: print(key, dictionary[key])
C. for value in dictionary.values(): print(value)
D. for key in dictionary.keys(): print(key)

Правильный ответ: A

Объяснение: Метод items() возвращает объект представления, содержащий
пары кортежей «ключ-значение». Это позволяет одновременно итерировать по
ключам и значениям в цикле 'for', что невозможно сделать, используя
только методы keys() или values().

**Вопрос 3.** В Python области видимости переменных имеют решающее значение
для понимания того, как осуществляется доступ к переменным или их
изменение внутри вложенных блоков кода. Если переменная с тем же именем
определена как внутри функции, так и вне ее, что произойдет, когда
функция попытается изменить эту переменную без использования каких-либо
дополнительных ключевых слов?

A. Функция напрямую изменит глобальную переменную без каких-либо ошибок.

B. Python выдаст ошибку SyntaxError из-за конфликта областей видимости.

C. Функция создаст новую локальную переменную с тем же именем, что и у
глобальной переменной, оставив глобальную переменную без изменений.

D. Глобальная переменная будет затененной, и ее значение изменится только
после завершения работы функции.

Правильный ответ: C

Объяснение: В Python переменные, объявленные внутри функции, по умолчанию
считаются локальными для этой функции. Если переменная с таким же именем
существует глобально, любые изменения внутри функции не затронут
глобальную переменную, если только не было явно использовано ключевое
слово 'global'.

**Вопрос 4.** Python поддерживает множество типов данных, и строки являются
одними из наиболее часто используемых. Какой из следующих способов является
правильным для объединения (конкатенации) трех строк в Python так, чтобы
результатом была одна строка без добавления лишних пробелов между ними?

A. "Python" + "is" + "awesome"
B. "Python", "is", "awesome"
C. "Python" + " " + "is" + " " + "awesome"
D. "Python".join(["is", "awesome"])

Правильный ответ: A

Объяснение: Оператор плюс (+) используется для конкатенации строк в Python.
Выражение "Python" + "is" + "awesome" дает в результате одну строку
"Pythonisawesome" без пробелов, тогда как другие варианты либо добавляют
пробелы, либо не выполняют объединение должным образом.

**Вопрос 5.** При определении функции в Python можно установить значения по
умолчанию для параметров, что обеспечивает большую гибкость при вызове
функции. Каков будет результат вызова следующей функции: 
def multiply(a, b=2): return a * b, если она вызвана как multiply(5)?

A. Функция вернет 5.

B. Функция вызовет исключение TypeError из-за отсутствующего аргумента.

C. Функция вернет 10, так как используется значение 'b' по умолчанию.

D. Функция вернет None, так как передан только один параметр.

Правильный ответ: C

Объяснение: В Python, если параметр функции имеет значение по умолчанию, его
можно опустить при вызове. При вызове multiply(5) переменная 'a' примет
значение 5, а 'b' использует свое значение по умолчанию (2), что в
результате даст 10.

**Вопрос 6.** Какой метод в Python можно использовать для замены части строки
другой строкой, и каков синтаксис этого метода, если вы хотите заменить 'cat'
на 'dog' в строке s = "The cat sat on the mat"?

A. s.replaceString('cat', 'dog')
B. s.replace('cat', 'dog')
C. s.stringReplace('cat', 'dog')
D. s.replaceAll('cat', 'dog')

Правильный ответ: B

Объяснение: Метод replace() в Python используется для замены частей строки на
другую строку. Правильный синтаксис: s.replace(old, new), где old — это
подстрока, которую нужно заменить, а new — подстрока, на которую выполняется
замена. В данном случае s.replace('cat', 'dog') заменит вхождения 'cat' на
'dog'.

**Вопрос 7.** При создании функции в Python, которая вычисляет факториал числа
с использованием рекурсии, какое из следующих определений функции
реализовано правильно и соответствует принципам рекурсии?

A. def factorial(n): return n * factorial(n-1) if n > 1 else 1

B. def factorial(n): return factorial(n-1) * n if n == 0 else 1

C. def factorial(n): factorial(n-1) * n

D. def factorial(n): return n * factorial(n) if n > 1 else 1

Правильный ответ: A

Объяснение: Правильный способ определения рекурсивной функции для вычисления
факториала числа n заключается в вызове самой функции с аргументом n-1 до
тех пор, пока не будет достигнут базовый случай. Вариант A правильно
реализует это с помощью n * factorial(n-1) для n > 1 и возвращает 1, когда
n равно 1 или меньше, корректно обрабатывая базовый случай рекурсии.

**Вопрос 8.** Какое из следующих утверждений о списках в Python является верным,
особенно когда речь идет о гибкости типов элементов, которые может содержать
список?

A. Списки Python могут содержать только элементы одного типа данных,
например, только целые числа или только строки.

B. Списки Python могут содержать элементы разных типов данных, таких как
целые числа, строки и объекты, одновременно в одном и том же списке.

C. Списки Python не могут содержать другие типы коллекций, такие как другие
списки или словари.

D. Списки Python являются неизменяемыми (immutable), что означает, что после
создания их элементы не могут быть изменены.

Правильный ответ: B

Объяснение: Списки в Python чрезвычайно гибки и могут содержать элементы
различных типов данных в одном списке. Это включает в себя любые комбинации,
такие как целые числа, строки и другие сложные объекты, включая вложенные
списки, словари или пользовательские объекты. Такая гибкость делает списки
мощным инструментом для различных задач.

**Вопрос 9.** Как в Python можно эффективно объединить несколько строк,
хранящихся в списке strings = ["Python", "is", "awesome"], чтобы получить
единую строку "Python is awesome"?

A. " ".join(strings)
B. strings.join(" ")
C. concatenate(" ", strings)
D. strings.concatenate(" ")

Правильный ответ: A

Объяснение: Метод join() строкового объекта можно использовать для
объединения каждого элемента итерируемого объекта (например, списка) в одну
строку, при этом строковый объект выступает в роли разделителя. В данном
случае " ".join(strings) использует пробел в качестве разделителя для
объединения всех элементов списка strings в одно связное предложение. Этот
метод эффективен и широко используется для подобных задач.

**Вопрос 10.** Рассмотрим блок кода Python для обработки исключений при
попытке преобразовать ввод пользователя (полученный через input()) в целое
число. Какая реализация правильно обрабатывает ввод, который может не быть
числом (например, слово 'five'), и выводит сообщение об ошибке?

A. try: num = int(input("Enter a number: ")) except ValueError:
print("That's not a valid number!")

B. try: num = int(input("Enter a number: ")) if not num: print("That's not a
valid number!")

C. num = int(input("Enter a number: ")) except ValueError: print("That's
not a valid number!")

D. try: num = int(input("Enter a number: ")) catch (ValueError):
print("That's not a valid number!")

Правильный ответ: A

Объяснение: В Python для обработки исключений (например, при неудачной
конвертации строки в число) используется блок try, за которым следует блок
except с указанием типа перехватываемого исключения. Вариант A верно
использует эти блоки для попытки парсинга ввода и обрабатывает ошибку
ValueError (которая возникает при провале конвертации), выводя
соответствующее сообщение.


```