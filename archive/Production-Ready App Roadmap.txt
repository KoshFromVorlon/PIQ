=== ЭТАП 1: ПРОЕКТИРОВАНИЕ И АРХИТЕКТУРА (DESIGN PHASE) ===

Прежде чем написать первую строчку кода:

1. Определение требований (SRS)
   - Функциональные требования: Что система должна делать (User Stories).
   - Нефункциональные требования (NFR): SLA, время отклика (latency), RPS
     (запросов в секунду), безопасность. Без этого вы строите дом без чертежа.

2. Выбор архитектуры
   - Monolith vs Microservices: Для старта (MVP) почти всегда лучше Модульный
     Монолит. Микросервисы вводят overhead, который убьет проект на старте.
   - База данных: SQL (PostgreSQL) для структурированных данных и транзакций.
     NoSQL (Mongo/Redis) только если есть специфические кейсы (кэш, логи).

3. Дизайн API (Contract First)
   - Опишите API до кода (OpenAPI/Swagger). Это позволит фронтенду и бэкенду
     работать параллельно.
   - Версионирование: Сразу заложите `/api/v1/`.

4. Моделирование данных
   - Нормализация БД (3NF).
   - Индексы: Подумайте, по каким полям будете искать чаще всего.

=== ЭТАП 2: НАСТРОЙКА ОКРУЖЕНИЯ (DEV EXPERIENCE) ===

Качество кода закладывается здесь.

1. Репозиторий и Git Flow
   - Ветки: `main` (prod), `develop` (dev), `feature/xyz`.
   - Защита веток: Запретить пуш в `main` без Code Review.

2. Линтеры и Форматтеры (Static Analysis)
   - Не надейтесь на память. Настройте `pre-commit hooks`.
   - Python стэк: `ruff` (быстрый линтер), `black` (форматирование), `mypy`
     (строгая типизация).
   - Если код не проходит линтер — он не попадает в репозиторий.

3. Управление зависимостями
   - Используйте `poetry` или `pip-tools`.
   - Lock-файлы (`poetry.lock`) обязательны, чтобы у всех разработчиков были
     одинаковые версии библиотек.

4. Конфигурация (12-Factor App)
   - Никаких паролей в коде! Все настройки через Переменные Окружения (.env).
   - Используйте `pydantic-settings` для валидации конфига при старте.

=== ЭТАП 3: РАЗРАБОТКА (DEVELOPMENT & SECURITY) ===

Пишем код, который трудно сломать.

1. Безопасность (Security First)
   - Authentication: JWT (access + refresh tokens).
   - Hashing: Никогда не храните пароли в открытом виде (используйте bcrypt
     или argon2).
   - Валидация: Никогда не доверяйте входным данным. Pydantic — ваш друг.
   - SQL Injection: Используйте ORM или параметризованные запросы.

2. Обработка ошибок
   - Не возвращайте клиенту сырые трейсбеки (Stack Trace) — это дыра в
     безопасности.
   - Унифицируйте формат ошибок: `{"error": "code", "detail": "message"}`.

3. Работа с Базой Данных
   - Миграции: Alembic. История изменений схемы БД должна быть в коде.
   - Проблема N+1: Следите за ORM, используйте жадную загрузку (eager loading)
     для связанных данных.
   - Транзакции: Операции, меняющие несколько таблиц, должны быть атомарны.

4. Асинхронность
   - Не блокируйте Event Loop. Тяжелые вычисления (CPU-bound) выносите в
     отдельные процессы или воркеры (Celery/TaskIQ).

=== ЭТАП 4: ТЕСТИРОВАНИЕ (QA & TESTING) ===

Если нет тестов — код не рабочий.

1. Пирамида тестирования
   - Unit Tests (70%): Тестируем отдельные функции и классы. Быстрые, без БД.
   - Integration Tests (20%): Тестируем API + БД (в Docker-контейнере).
   - E2E Tests (10%): Полный сценарий пользователя.

2. Mocking
   - Внешние API (платежки, почта) всегда мокаем. Тесты должны работать без
     интернета.

3. CI/CD Pipeline (GitHub Actions / GitLab CI)
   - При каждом Pull Request: Запуск линтеров -> Запуск тестов.
   - Если тесты упали — мержить нельзя.

=== ЭТАП 5: ПРОИЗВОДИТЕЛЬНОСТЬ И НАДЕЖНОСТЬ (RELIABILITY) ===

Готовимся к нагрузкам.

1. Кэширование
   - Redis. Кэшируйте "дорогие" запросы на чтение.
   - Invalidation: Самое сложное — вовремя сбросить кэш.

2. Rate Limiting
   - Защита от DDoS и спама. Ограничьте количество запросов с одного IP
     (например, 100 req/min).

3. Graceful Shutdown
   - Приложение должно уметь корректно завершать текущие запросы перед
     остановкой, а не обрывать соединения.

4. Idempotency (Идемпотентность)
   - Повторный POST-запрос (например, оплата) не должен приводить к двойному
     списанию денег.

=== ЭТАП 6: ДЕПЛОЙ И НАБЛЮДАЕМОСТЬ (OPS & OBSERVABILITY) ===

Production — это черный ящик. Нам нужен фонарик.

1. Docker & Containerization
   - Multi-stage builds: Образ для продакшена должен быть минимальным (без
     компиляторов и исходников).
   - Не запускайте контейнеры от `root` пользователя!

2. Логирование
   - Структурированные логи (JSON). Обычный текст трудно парсить машине.
   - Уровни: INFO (бизнес-события), ERROR (ошибки), DEBUG (только для dev).
   - Не логируйте чувствительные данные (пароли, номера карт)!

3. Мониторинг и Метрики
   - Prometheus + Grafana.
   - Ключевые метрики (RED Method):
     - Rate (количество запросов).
     - Errors (количество 500-к).
     - Duration (время ответа).

4. Sentry (Error Tracking)
   - Вы должны узнавать об ошибках раньше пользователей. Sentry шлет алерты
     с контекстом ошибки.

=== ЧЕК-ЛИСТ ГОТОВНОСТИ К ПРОДУ (DEFINITION OF DONE) ===

[ ] Код отформатирован и типизирован (Ruff/Mypy).
[ ] Покрытие тестами (Coverage) > 80%.
[ ] Секреты (API Keys, DB Pass) не в коде.
[ ] Настроены CORS (Cross-Origin Resource Sharing).
[ ] База данных закрыта от внешнего мира (доступна только бэкенду).
[ ] Настроен HTTPS (SSL/TLS).
[ ] Есть бэкапы базы данных (и проверено восстановление из них!).
[ ] Логи пишутся в JSON и собираются (ELK/Loki).
[ ] Настроен мониторинг (Grafana) и алерты (в Telegram/Slack).
