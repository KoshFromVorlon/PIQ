================================================================================
РАЗДЕЛ 1: LAYER 7 — ПРИКЛАДНОЙ УРОВЕНЬ (HTTP, WEB, DNS)
Самый важный раздел для веб-разработчика.
================================================================================

1. ИЗ ЧЕГО СОСТОИТ HTTP-ЗАПРОС И HTTP-ОТВЕТ?
ОТВЕТ:
HTTP-сообщение (и запрос, и ответ) состоит из трех основных частей:
1. Стартовая строка (Start Line):
   - В запросе: Метод (GET) + Путь (/index.html) + Версия протокола (HTTP/1.1).
   - В ответе: Версия + Код состояния (200) + Текстовое пояснение (OK).
2. Заголовки (Headers):
   Метаданные в формате "Ключ: Значение". Например, `Content-Type: application/
   json` или `User-Agent`. Они говорят серверу, как обрабатывать запрос.
3. Пустая строка:
   Обязательный разделитель, отделяющий заголовки от тела сообщения.
4. Тело (Body):
   Сами данные (HTML, JSON, картинка). В GET-запросах тело обычно отсутствует,
   в POST/PUT — содержит передаваемые данные.

2. В ЧЕМ РАЗНИЦА МЕЖДУ МЕТОДАМИ GET И POST?
ОТВЕТ:
- GET: Используется для получения данных. Параметры передаются прямо в URL
  (видны всем в строке браузера). Идемпотентен (повтор запроса безопасен).
  Активно кэшируется браузером.
- POST: Используется для отправки данных (создания ресурса). Параметры переда-
  ются в теле запроса (Body) и скрыты из адресной строки. Не идемпотентен
  (повторная отправка создаст дубликат записи). Обычно не кэшируется.

3. ЧТО ТАКОЕ ИДЕМПОТЕНТНОСТЬ МЕТОДОВ HTTP?
ОТВЕТ:
Идемпотентность означает, что если сделать один и тот же запрос несколько раз
подряд, итоговое состояние сервера будет таким же, как после первого раза.
- Идемпотентные: GET, PUT, DELETE. (Сколько бы раз ни удаляли запись по ID 5,
  её не станет "больше удаленной", результат один — записи нет).
- Не идемпотентные: POST. (Если 5 раз отправить запрос на оплату, спишется 5
  сумм, так как каждый запрос создает новую транзакцию).

4. В ЧЕМ РАЗНИЦА МЕЖДУ PUT И PATCH?
ОТВЕТ:
Оба используются для обновления данных, но логика разная:
- PUT (Полная замена): Клиент присылает готовый объект целиком. Если какое-то
  поле не передано, оно затирается или сбрасывается в null. Вы как бы кладете
  новый файл поверх старого.
- PATCH (Частичное изменение): Клиент присылает только те поля, которые нужно
  изменить (например, только `status="active"`). Остальные данные остаются
  нетронутыми.

5. ОБЪЯСНИТЕ СМЫСЛ ОСНОВНЫХ ГРУПП КОДОВ ОТВЕТА (STATUS CODES).
ОТВЕТ:
- 1xx (Informational): "Запрос принят, продолжай процесс".
- 2xx (Success): Всё прошло успешно. (200 OK — норма, 201 Created — создано).
- 3xx (Redirection): Нужно перейти в другое место. (301 — перемещено навсегда,
  браузер запомнит новый адрес; 302 — временно).
- 4xx (Client Error): Ошибка на стороне клиента. (400 Bad Request — кривой
  запрос, 401 Unauthorized — не залогинен, 403 Forbidden — нет прав, 404 Not
  Found — не найдено).
- 5xx (Server Error): Ошибка сервера. (500 Internal Server Error — упал код,
  502 Bad Gateway — сервер перегружен или Nginx не достучался до бэкенда).

6. HTTP — ЭТО STATELESS ПРОТОКОЛ. КАК ТОГДА РАБОТАЕТ АВТОРИЗАЦИЯ?
ОТВЕТ:
Stateless значит, что сервер не помнит предыдущий запрос. Каждый запрос —
как с чистого листа. Чтобы связать запросы, мы передаем идентификатор:
1. Cookies: Сервер ставит куку (Set-Cookie), и браузер автоматически
   прикрепляет её к каждому следующему запросу.
2. Headers (Token): Клиент хранит токен (например, JWT) в памяти и явно
   добавляет его в заголовок `Authorization: Bearer <token>`.

7. КАК РАБОТАЕТ HTTPS И ЗАЧЕМ НУЖЕН SSL/TLS?
ОТВЕТ:
HTTPS — это HTTP поверх протокола шифрования TLS. Он защищает данные от
прослушки (Man-in-the-Middle).
Процесс (упрощенно):
1. Клиент просит защищенное соединение.
2. Сервер отправляет свой публичный сертификат.
3. Клиент проверяет валидность сертификата в Центре Сертификации (CA).
4. Клиент и сервер договариваются о сеансовом ключе шифрования (Handshake).
5. Дальше весь трафик шифруется этим симметричным ключом.

8. ЧЕМ WEBSOCKETS ОТЛИЧАЮТСЯ ОТ ОБЫЧНОГО HTTP?
ОТВЕТ:
- HTTP: Модель "Запрос-Ответ". Клиент спросил — сервер ответил — связь
  разорвалась. Чтобы получить новые данные, нужно спросить снова (Polling).
- WebSocket: Постоянный двусторонний канал (Full Duplex). Соединение устанав-
  ливается один раз (через HTTP Handshake) и держится открытым. Сервер может
  сам отправить данные клиенту в любой момент. Идеально для чатов/игр.

================================================================================
РАЗДЕЛ 2: LAYER 4 — ТРАНСПОРТНЫЙ УРОВЕНЬ (TCP/UDP, ПОРТЫ)
Отвечает за доставку данных между приложениями.
================================================================================

9. В ЧЕМ РАЗНИЦА МЕЖДУ TCP И UDP?
ОТВЕТ:
- TCP (Transmission Control Protocol): Надежный. Гарантирует доставку
  пакетов, их правильный порядок и целостность. Требует установки соединения.
  Медленнее из-за проверок. (Используется для Web, почты, передачи файлов).
- UDP (User Datagram Protocol): Быстрый, но ненадежный. Пакеты могут
  теряться или приходить не по порядку. Нет подтверждения доставки.
  (Используется для стриминга видео, звонков, онлайн-игр, DNS).

10. ЧТО ТАКОЕ "ТРОЙНОЕ РУКОПОЖАТИЕ" (3-WAY HANDSHAKE) В TCP?
ОТВЕТ:
Процесс установки надежного соединения перед передачей данных:
1. SYN: Клиент шлет запрос "Хочу соединиться" (синхронизация).
2. SYN-ACK: Сервер отвечает "Вижу тебя, готов соединиться".
3. ACK: Клиент отвечает "Отлично, начинаем передачу".
Только после этого шага начинают передаваться реальные данные.

11. ЧТО ТАКОЕ ПОРТ И СОКЕТ?
ОТВЕТ:
- Порт: Числовой идентификатор процесса на компьютере (от 0 до 65535).
  Позволяет ОС понять, какой программе отдать пришедший пакет (80 — веб-сервер,
  5432 — база данных Postgres).
- Сокет: Комбинация IP-адреса и Порта (например, 192.168.1.5:8000). Это
  конечная логическая точка соединения.

================================================================================
РАЗДЕЛ 3: LAYER 3 — СЕТЕВОЙ УРОВЕНЬ (IP, ROUTING)
Отвечает за адресацию и маршрут.
================================================================================

12. В ЧЕМ РАЗНИЦА МЕЖДУ 127.0.0.1 И 0.0.0.0?
ОТВЕТ:
- 127.0.0.1 (localhost): Интерфейс "петли" (loopback). Сервис, запущенный
  на этом IP, доступен ТОЛЬКО изнутри этого же компьютера. Снаружи к нему
  не подключиться.
- 0.0.0.0: Означает "слушать все доступные сетевые интерфейсы". Если
  запустить сервер на 0.0.0.0, он будет доступен и локально, и по локальной
  сети (по IP компьютера), и из интернета (если есть белый IP).

13. ЧТО ТАКОЕ NAT И ЗАЧЕМ ОН НУЖЕН?
ОТВЕТ:
NAT (Network Address Translation) — трансляция сетевых адресов. Это техно-
логия, которая позволяет множеству устройств в домашней сети (с приватными
IP типа 192.168.x.x) выходить в интернет через один публичный IP-адрес
роутера. Именно поэтому вы не можете напрямую обратиться к ноутбуку друга
по его локальному IP.

14. КАК РАБОТАЕТ DNS (DOMAIN NAME SYSTEM)?
ОТВЕТ:
DNS переводит понятное человеку имя (google.com) в машинный IP-адрес
(142.250.x.x). Цепочка поиска (если в кэше пусто):
1. Браузер спрашивает у DNS-резолвера провайдера.
2. Резолвер идет к Root-серверам (точка в конце домена).
3. Root отправляет к TLD-серверу (зона .com).
4. TLD отправляет к Authoritative-серверу (владелец зоны google.com).
5. Тот отдает конкретный IP-адрес.

================================================================================
БОНУС: SYSTEM DESIGN ВОПРОС (СБОРНАЯ СОЛЯНКА)
================================================================================

15. ЧТО ПРОИСХОДИТ, КОГДА ВВОДИШЬ GOOGLE.COM И ЖМЕШЬ ENTER?
ОТВЕТ (По шагам):
1. DNS (L7/UDP): Браузер узнает IP-адрес сервера google.com.
2. TCP Handshake (L4): Браузер открывает соединение с этим IP (порт 443).
3. TLS Handshake (L6/L7): Происходит обмен ключами шифрования.
4. HTTP Request (L7): Браузер отправляет зашифрованный GET-запрос.
5. Routing (L3): Пакеты бегут через роутеры интернета к дата-центру Google.
6. Server Processing: Балансировщик принимает запрос, передает бэкенду,
   тот генерирует HTML.
7. HTTP Response (L7): Сервер отправляет HTML обратно.
8. Rendering: Браузер отрисовывает страницу (DOM, CSS, JS).


================================================================================
УРОВЕНЬ: JUNIOR (БАЗА)
Основы, без которых нельзя писать веб-приложения.
================================================================================

ВОПРОС 1. В чем принципиальная разница между методами GET и POST, и что такое
"Идемпотентность"?

ОТВЕТ:
Чтобы ответить на этот вопрос, нужно разобрать структуру HTTP-запроса и
понятие изменения состояния сервера.

1. Структура передачи данных:
   - GET: Предназначен только для *получения* данных. Параметры передаются в
     строке URL (Query String). Пример: `?id=5&name=alex`. У этого метода нет
     Тела (Body).
     Ограничение: Нельзя передавать большие объемы данных или секретные данные
     (пароли), так как URL сохраняется в истории браузера и логах прокси.
   - POST: Предназначен для *отправки* данных (создания ресурса). Параметры
     передаются в Теле запроса (Body). Они не видны в URL. Объем данных не
     ограничен (можно загружать файлы).

2. Кэширование:
   - GET-запросы активно кэшируются браузером и CDN (Content Delivery
     Network), так как считается, что они не меняют данные на сервере.
   - POST-запросы по умолчанию не кэшируются.

3. Идемпотентность (Ключевое понятие):
   Идемпотентность — это свойство метода, при котором повторный вызов того же
   самого запроса не меняет состояние системы по сравнению с первым вызовом.
   - GET идемпотентен. Сколько бы раз вы ни запросили список товаров, список
     товаров от этого не изменится (вы ничего не удаляете и не добавляете).
   - POST НЕ идемпотентен. Если вы отправите запрос "Списать 100 рублей" два
     раза (например, у пользователя дрогнула рука), сервер спишет 200 рублей.
     Каждый вызов создает *новую* транзакцию.

ВОПРОС 2. Объясните разницу между TCP и UDP на примерах из реальной жизни.

ОТВЕТ:
Это протоколы Транспортного уровня (L4), которые решают одну задачу —
доставку данных, но диаметрально противоположными способами.

1. TCP (Transmission Control Protocol) — "Надежный педант".
   - Гарантия доставки: Если пакет потерялся в пути, TCP узнает об этом (так
     как не пришло подтверждение ACK) и отправит его снова.
   - Порядок (Ordering): Пакеты могут приходить вразнобой. TCP на стороне
     получателя расставит их в правильном порядке перед тем, как отдать
     приложению.
   - Пример: Загрузка веб-страницы или отправка письма. Если потеряется хоть
     одна буква, смысл текста изменится. Нам нужна 100% точность, даже ценой
     скорости.

2. UDP (User Datagram Protocol) — "Быстрый почтальон".
   - "Выстрелил и забыл": Отправляет пакеты максимально быстро, не дожидаясь
     подтверждения.
   - Нет гарантий: Если пакет потерялся — он потерялся навсегда.
   - Нет порядка: Пакеты обрабатываются по мере поступления.
   - Пример: Стриминг видео или звонок в Zoom. Если выпадает один кадр или
     звук "квакнет" на миллисекунду, это не страшно. Страшнее, если видео
     начнет тормозить, пытаясь догрузить этот старый кадр.

ВОПРОС 3. Что означают коды ответа HTTP (Status Codes)? Назовите основные
диапазоны.

ОТВЕТ:
Код ответа — это трехзначное число, которое сервер сообщает клиенту, чтобы
объяснить результат обработки запроса.

- 1xx (Informational): "Запрос получен, продолжаю обработку". Встречается
  редко. Пример: 101 Switching Protocols (используется при переходе на
  WebSockets).
- 2xx (Success): "Все хорошо".
  - 200 OK: Стандартный успешный ответ.
  - 201 Created: Ресурс успешно создан (обычно ответ на POST).
- 3xx (Redirection): "Иди ищи в другом месте".
  - 301 Moved Permanently: Ресурс переехал навсегда. Браузер запомнит это и
    в следующий раз сам пойдет по новому адресу.
  - 302 Found (Temporary Redirect): Временный переезд.
- 4xx (Client Error): "Ты ошибся". Виноват тот, кто отправлял запрос.
  - 400 Bad Request: Сервер не понял запрос (кривой JSON, нет полей).
  - 401 Unauthorized: Пользователь не представился (нет токена).
  - 403 Forbidden: Пользователь представился, но ему сюда нельзя (нет прав).
  - 404 Not Found: Такого адреса не существует.
- 5xx (Server Error): "Я ошибся". Виноват сервер.
  - 500 Internal Server Error: Необработанная ошибка в коде (Exception).
  - 502 Bad Gateway: Сервер, который стоит на входе (Nginx), не смог
    получить ответ от вашего приложения (Python/Go/Node). Обычно значит, что
    приложение упало.

================================================================================
УРОВЕНЬ: MIDDLE (ПОНИМАНИЕ ПРОЦЕССОВ)
Механика работы сети и безопасности.
================================================================================

ВОПРОС 4. Как устанавливается TCP-соединение? Опишите процесс "Тройного
рукопожатия" (3-Way Handshake).

ОТВЕТ:
До того, как отправить хоть один байт полезных данных (например, HTTP-запрос),
клиент и сервер должны "договориться" и открыть сессию. Этот процесс
называется Handshake.

Действующие лица: Клиент (инициатор) и Сервер (слушатель).
Флаги TCP: SYN (Synchronize — хочу начать), ACK (Acknowledge — подтверждаю).

Шаг 1. SYN (Client -> Server)
Клиент отправляет пакет с флагом SYN. Он генерирует случайное число
(Sequence Number = X), которое будет служить точкой отсчета для нумерации
всех будущих пакетов. Смысл: "Давай дружить, я начну считать с X".

Шаг 2. SYN-ACK (Server -> Client)
Сервер получает SYN. Он должен подтвердить получение и предложить свои
условия. Он отправляет пакет с флагами SYN и ACK.
- ACK = X + 1 (Подтверждаю, что получил X, жду следующий).
- Sequence Number = Y (Мое случайное число для отсчета).
Смысл: "Я тебя услышал. Давай дружить. Я буду считать с Y".

Шаг 3. ACK (Client -> Server)
Клиент получает ответ. Он отправляет последний пакет с флагом ACK.
- ACK = Y + 1 (Подтверждаю, что получил Y).
Смысл: "Соединение установлено, начинаю слать данные".

Только после этого начинается передача HTTP-трафика.

ВОПРОС 5. Как работает HTTPS? Что такое SSL/TLS Handshake?

ОТВЕТ:
HTTPS — это не отдельный протокол, а обычный HTTP, завернутый в шифрование
TLS (Transport Layer Security). Задача: сделать так, чтобы никто посередине
(провайдер, хакер в кафе) не мог прочитать данные.

Ключевые понятия:
- Асимметричное шифрование: Есть Публичный ключ (зашифровать может кто
  угодно) и Приватный ключ (расшифровать может только владелец). Медленно,
  но безопасно для обмена секретами.
- Симметричное шифрование: Один ключ и для зашифровки, и для расшифровки.
  Работает очень быстро.

Процесс TLS Handshake (упрощенно TLS 1.2):
1. Client Hello: Клиент говорит: "Я поддерживаю такие-то алгоритмы
   шифрования".
2. Server Hello + Certificate: Сервер выбирает алгоритм и присылает свой
   SSL-сертификат. В сертификате лежит Публичный ключ сервера.
3. Проверка: Клиент проверяет, что сертификат настоящий (подписан доверенным
   Центром Сертификации) и срок действия не истек.
4. Обмен ключом (Key Exchange): Клиент генерирует случайный "Пре-мастер
   ключ", шифрует его Публичным ключом сервера и отправляет серверу.
   Расшифровать это может ТОЛЬКО сервер своим Приватным ключом.
5. Генерация сессионного ключа: Теперь у обоих есть общий секрет. Из него
   математически создается Симметричный ключ сессии.
6. Шифрованный туннель: Дальше весь обмен данными идет с использованием
   быстрого симметричного ключа.

ВОПРОС 6. Что такое Cookies и как обеспечить их безопасность (флаги
HttpOnly, Secure, SameSite)?

ОТВЕТ:
Cookie (Кука) — это маленькая строка данных (ключ=значение), которую сервер
присылает клиенту в заголовке `Set-Cookie`. Браузер сохраняет её и
автоматически прикрепляет ко ВСЕМ последующим запросам на этот домен.

Проблемы безопасности кук:
1. XSS (Cross-Site Scripting): Если злоумышленник внедрит JS-код на вашу
   страницу, он может прочитать `document.cookie` и украсть сессию
   пользователя.
   РЕШЕНИЕ: Флаг `HttpOnly`. Запрещает доступ к куке через JavaScript. Кука
   передается только в HTTP-запросах, скрипты ее не видят.

2. Перехват трафика: В открытом Wi-Fi куку можно перехватить.
   РЕШЕНИЕ: Флаг `Secure`. Браузер отправит куку только если соединение
   установлено через HTTPS. По обычному HTTP кука не полетит.

3. CSRF (Cross-Site Request Forgery): Злоумышленник делает сайт-ловушку с
   кнопкой, которая шлет POST-запрос в ваш банк. Так как браузер шлет куки
   автоматически, банк подумает, что это вы переводите деньги.
   РЕШЕНИЕ: Флаг `SameSite`.
   - `SameSite=Strict`: Кука летит только если вы находитесь на сайте банка.
   - `SameSite=Lax`: Кука летит при переходе по ссылке, но не летит при
     фоновых запросах (картинки, формы) с чужих сайтов.

================================================================================
УРОВЕНЬ: MIDDLE+ / SENIOR (ГЛУБОКОЕ ПОГРУЖЕНИЕ)
Архитектурные проблемы и оптимизация.
================================================================================

ВОПРОС 7. Что такое Head-of-Line (HoL) Blocking в HTTP/1.1 и HTTP/2?

ОТВЕТ:
Head-of-Line Blocking ("Блокировка начала очереди") — это ситуация, когда
задержка одного пакета данных останавливает обработку всех последующих.

В HTTP/1.1 (L7 Blocking):
Браузер может открыть до 6 TCP-соединений к одному домену. Запросы в одном
соединении идут строго по очереди.
Если 1-й запрос (тяжелая картинка) грузится долго, то 2-й и 3-й (маленькие
JSON-файлы) ждут в очереди, даже если они уже готовы на сервере.
Решение HTTP/2: Мультиплексирование. Все запросы разбиваются на мелкие
фреймы и летят вперемешку в одном TCP-соединении.

В HTTP/2 (L4 Blocking):
Проблема спустилась на уровень TCP. Все фреймы летят в одной "трубе". TCP
гарантирует порядок доставки байтов. Если ОДИН IP-пакет с кусочком картинки
потерялся в сети, операционная система получателя ставит на паузу ВСЮ
обработку (включая фреймы других запросов, которые успешно долетели), пока
потерянный пакет не будет переотправлен.
Решение HTTP/3 (QUIC): Переход на протокол UDP, где потоки данных независимы
друг от друга. Потеря пакета в одном потоке не тормозит остальные.

ВОПРОС 8. Что такое состояние TIME_WAIT в TCP и как оно может "убить" сервер?

ОТВЕТ:
Когда TCP-соединение закрывается, оно не исчезает мгновенно. Сторона, которая
первой сказала "Давай прощаться" (послала FIN), после закрытия переходит в
состояние TIME_WAIT.

Зачем это нужно:
Сокет висит в этом состоянии (обычно 60 секунд), чтобы поймать любые
"заблудившиеся" в сети пакеты этого разговора и молча их отбросить. Если бы
сокет сразу освободился, и на нем тут же открылось новое соединение, старый
заблудившийся пакет мог бы вклиниться в новый разговор и сломать данные.

Проблема:
Каждое соединение требует уникальную пару (IP клиента + Порт клиента).
Количество портов ограничено (всего 65535, доступных для исхода ~28000).
Если ваш сервер делает много исходящих запросов (например, парсер или
микросервис), и он постоянно открывает/закрывает соединения, то очень скоро
все свободные порты окажутся заняты "мертвыми" сокетами в статусе TIME_WAIT.
Новые соединения создавать будет не из чего. Приложение упадет с ошибкой
`EADDRNOTAVAIL` (Cannot assign requested address).

ВОПРОС 9. Что такое MTU и MSS? Почему фрагментация IP-пакетов — это плохо?

ОТВЕТ:
1. MTU (Maximum Transmission Unit):
   Это физическое ограничение сети. Максимальный размер пакета данных, который
   можно передать без разрезания. Стандарт для Ethernet (интернета) — 1500
   байт. Это как размер грузовика.

2. MSS (Maximum Segment Size):
   Это параметр TCP. Он говорит: "Сколько полезных данных я могу положить в
   один пакет, чтобы он влез в MTU?".
   MSS = MTU (1500) - Заголовок IP (20) - Заголовок TCP (20) = 1460 байт.

3. Проблема фрагментации (L3):
   Если приложение (обычно через UDP, где нет MSS) попытается отправить пакет
   размером 4000 байт, то протокол IP будет вынужден разрезать его на 3
   фрагмента (Фрагментация), чтобы они пролезли в провода.
   Почему это плохо:
   В IP нет гарантии доставки. Если потеряется ХОТЬ ОДИН из 3-х фрагментов,
   весь исходный пакет (4000 байт) считается уничтоженным. Его невозможно
   собрать. Весь пакет нужно слать заново. Это приводит к резкому падению
   производительности сети.
   В TCP фрагментации избегают, заранее договариваясь о размере MSS.


================================================================================
БЛОК 1: EVOLUTION OF HTTP (L7 & L4)
Самые сложные архитектурные вопросы по протоколам.
================================================================================

1-2. HEAD-OF-LINE (HOL) BLOCKING: РАЗНИЦА НА L7 И L4
ОТВЕТ:
Проблема "Блокировки начала очереди" (HoL) возникает, когда задержка одного
пакета тормозит все остальные.
- На уровне L7 (HTTP/1.1): Браузер шлет запросы по очереди. Если запрос №1
  (тяжелая картинка) грузится долго, запросы №2 и №3 ждут, даже если они
  мелкие.
  РЕШЕНИЕ HTTP/2: Мультиплексирование. Все запросы нарезаются на мелкие
  бинарные фреймы и летят параллельно внутри одного TCP-соединения.
- На уровне L4 (TCP): Даже в HTTP/2 все фреймы летят в одной "трубе" TCP.
  TCP гарантирует порядок. Если потерялся ОДИН пакет с данными картинки,
  операционная система тормозит ВСЮ очередь (включая CSS и JS, которые уже
  долетели), пока потерянный пакет не будет переотправлен.
  РЕШЕНИЕ HTTP/3 (QUIC): Отказ от TCP в пользу UDP. Потоки независимы. Потеря
  пакета в одном потоке не тормозит остальные.

3. HPACK И СЖАТИЕ ЗАГОЛОВКОВ
ОТВЕТ:
В современном вебе заголовки (User-Agent, Cookies, Tokens) могут весить больше,
чем само тело запроса. В HTTP/1.1 они передаются текстом каждый раз.
HPACK (в HTTP/2) использует два механизма:
1. Статический словарь: Часто используемые поля (method: GET) заменяются на
   короткие ID (например, 1 байт вместо 10).
2. Динамический словарь: Если клиент один раз отправил User-Agent, сервер
   сохраняет его в таблицу и присваивает ID. В следующем запросе клиент шлет
   только этот ID.

5. KEEP-ALIVE И PIPELINING
ОТВЕТ:
- Keep-Alive: Позволяет не разрывать TCP-соединение после каждого запроса.
  Экономит время на TCP Handshake и SSL Handshake. Соединение закрывается по
  тайм-ауту или лимиту запросов (Keep-Alive: timeout=5, max=1000).
- HTTP Pipelining: Старая идея из HTTP/1.1 отправить пачку запросов, не
  дожидаясь ответов. Умерла, так как сервер обязан отвечать строго в том же
  порядке (см. проблему HoL Blocking L7), что часто приводило к глюкам прокси.

================================================================================
БЛОК 2: CACHING & HEADERS (RFC 7234)
Управление состоянием и производительностью.
================================================================================

7. ETAG VS LAST-MODIFIED
ОТВЕТ:
Механизмы валидации кэша (браузер спрашивает: "Моя версия файла еще актуальна?").
- Last-Modified: Сервер шлет дату изменения файла. Минусы: точность до 1
  секунды (мало для быстрых правок), изменение даты не всегда меняет контент.
- ETag (Entity Tag): Хэш контента (например, MD5). Это "отпечаток пальца"
  файла.
  ПРОЦЕСС: Браузер шлет заголовок `If-None-Match: "hash123"`. Если на сервере
  хэш тот же, он отвечает `304 Not Modified` (тела ответа нет, качай из кэша).
  ETag приоритетнее и надежнее.

8. CACHE-CONTROL: NO-CACHE VS NO-STORE
ОТВЕТ:
Самая частая ошибка на собеседованиях.
- no-store: "Запрещено кэшировать ВООБЩЕ". Ни браузер, ни CDN, ни прокси не
  должны сохранять этот ответ. Для банковских данных.
- no-cache: "Кэшировать можно, НО перед использованием обязательно спроси
  сервер, не изменился ли файл" (через ETag). То есть файл лежит на диске,
  но требует подтверждения актуальности.

10. COOKIES: ФЛАГИ БЕЗОПАСНОСТИ
ОТВЕТ:
- HttpOnly: Запрещает доступ к куке через JavaScript (`document.cookie`).
  Защищает от кражи сессии при XSS-атаках.
- Secure: Кука передается только по HTTPS. В незашифрованном HTTP она не
  отправится.
- SameSite:
  - Strict: Кука летит только если вы находитесь на том же сайте. (Не сработает
    при переходе по ссылке из почты).
  - Lax: Кука летит при безопасных переходах (по ссылке), но не летит при
    вставке картинки или iframe с чужого сайта. Защищает от CSRF.

================================================================================
БЛОК 3: API ARCHITECTURE & PATTERNS
Системный дизайн бэкенда.
================================================================================

11. IDEMPOTENCY KEY (ИДЕМПОТЕНТНОСТЬ POST)
ОТВЕТ:
Проблема: Клиент нажал "Оплатить", интернет моргнул, клиент не получил ответ,
но деньги списались. Клиент нажимает снова -> двойное списание.
Решение:
1. Клиент генерирует уникальный ID (UUID) запроса и шлет его в заголовке
   `Idempotency-Key`.
2. Сервер (Бэкенд) проверяет в БД/Redis, был ли уже запрос с таким ключом.
3. Если БЫЛ: Сервер не выполняет логику, а просто отдает сохраненный результат
   прошлого выполнения.
4. Если НЕ БЫЛ: Выполняет, сохраняет результат и ключ, отдает ответ.

12. GRPC VS REST
ОТВЕТ:
- REST: Текстовый формат (JSON), человекочитаемый, использует методы HTTP
  (GET, POST). Оверхед на парсинг текста и передачу имен полей.
- gRPC: Бинарный протокол (Protobuf) поверх HTTP/2.
  Плюсы: Строгая типизация (.proto схемы), сжатие данных (в разы меньше JSON),
  встроенная кодогенерация клиентов.
  Минусы: Нельзя отладить просто через curl/браузер, нужна схема.

14. CORS И PREFLIGHT REQUESTS
ОТВЕТ:
Браузеры блокируют запросы с одного домена (site.com) на другой (api.com)
из соображений безопасности.
Preflight Request (OPTIONS): Перед тем как отправить "опасный" запрос
(например, POST с JSON или кастомными заголовками), браузер сам шлет
предварительный запрос методом OPTIONS.
Сервер должен ответить заголовками:
`Access-Control-Allow-Origin: https://site.com`
`Access-Control-Allow-Methods: POST`
Если сервер дал добро, браузер шлет основной запрос.

================================================================================
БЛОК 4: TLS/SSL INTERNALS (L6)
Безопасность и шифрование.
================================================================================

16. TLS HANDSHAKE (ПОШАГОВО)
ОТВЕТ:
1. Client Hello: "Привет, я умею шифровать алгоритмами А и Б, вот мое
   случайное число".
2. Server Hello: "Выбираю алгоритм А, вот мое случайное число, вот мой
   Сертификат (Публичный ключ)".
3. Verification: Клиент проверяет подпись сертификата в центре сертификации.
4. Key Exchange: Клиент генерирует "Пре-мастер ключ", шифрует его публичным
   ключом сервера и отправляет серверу.
5. Session Key: Обе стороны, используя случайные числа и пре-мастер ключ,
   математически вычисляют одинаковый "Сеансовый ключ" (симметричный).
6. Дальше весь обмен идет с шифрованием этим быстрым ключом.

18. SNI (SERVER NAME INDICATION)
ОТВЕТ:
Проблема: Сервер (Nginx) хостит 10 сайтов на одном IP. Клиент стучится на 443
порт. Какой SSL-сертификат отдать клиенту, если мы еще не расшифровали запрос
и не видим заголовок Host?
Решение: SNI — это расширение TLS. Клиент передает имя домена, к которому
хочет подключиться, В ОТКРЫТОМ ВИДЕ внутри "Client Hello" (самый первый пакет),
еще до начала шифрования. Сервер читает это поле и отдает нужный сертификат.

================================================================================
БЛОК 5: TCP MECHANICS (L4)
Надежность доставки.
================================================================================

22-23. FLOW CONTROL VS CONGESTION CONTROL
ОТВЕТ:
Это два разных механизма торможения.
1. Flow Control (Защита получателя): Бэкенд говорит: "Мой буфер полон, я не
   успеваю обрабатывать". Механизм: TCP Sliding Window. Получатель шлет размер
   окна (сколько байт он готов принять). Если 0 — отправитель замолкает.
2. Congestion Control (Защита сети): Роутер провайдера перегружен, пакеты
   теряются. Отправитель понимает это по потере пакетов и сам снижает
   скорость (алгоритмы Slow Start, Reno, Cubic), чтобы не "положить" сеть.

25. NAGLE’S ALGORITHM И TCP_NODELAY
ОТВЕТ:
Алгоритм Нагла был создан, чтобы не гонять по сети пакеты с 1 байтом полезной
информации (overhead заголовков 40 байт). Он накапливает мелкие данные в
буфер и отправляет их пачкой.
Проблема: В реал-тайм играх или SSH нам нужно, чтобы нажатие клавиши улетало
мгновенно. Нагл создает лаг.
Решение: Опция сокета `TCP_NODELAY` отключает алгоритм Нагла. Данные улетают
сразу.

27. TIME_WAIT И PORT EXHAUSTION
ОТВЕТ:
Когда сервер (или клиент) активно закрывает соединение, сокет не удаляется
сразу, а переходит в статус TIME_WAIT на 1-4 минуты.
Зачем: Чтобы убедиться, что все "заблудившиеся" в сети пакеты дошли и были
отброшены, и не попали в новое соединение на том же порту.
Опасность: На высоконагруженном клиенте (например, парсер) могут закончиться
свободные порты (их всего 65535, а доступных ~28000), так как все они будут
висеть в TIME_WAIT.

================================================================================
БЛОК 6: NETWORK & INFRASTRUCTURE (L3)
================================================================================

32. MTU (MAXIMUM TRANSMISSION UNIT) И ФРАГМЕНТАЦИЯ
ОТВЕТ:
MTU — максимальный размер пакета, который может пролезть через интерфейс без
разрезания. Стандарт для Ethernet — 1500 байт.
Если приложение отправит пакет размером 4000 байт (через UDP), IP-протокол
разрежет его на 3 фрагмента.
Почему это плохо: Если в сети потеряется хоть один маленький фрагмент, весь
большой пакет (4000 байт) считается битым и отбрасывается. Это резко снижает
надежность. В TCP этой проблемы нет (там есть MSS), в UDP — есть.

36. ANYCAST IP
ОТВЕТ:
Магия, благодаря которой Google DNS (8.8.8.8) отвечает быстро из любой страны.
Обычно IP-адрес уникален для одного сервера. В Anycast один и тот же IP
анонсируется через протокол BGP из сотен разных дата-центров по миру.
Когда вы шлете запрос на 8.8.8.8, магия маршрутизации направляет вас к
физически ближайшему (топологически) серверу. Если дата-центр падает,
маршруты перестраиваются на следующий ближайший.